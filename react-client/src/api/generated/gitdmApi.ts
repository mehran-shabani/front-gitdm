/**
 * Generated by orval v7.4.0 üç∫
 * Do not edit manually.
 * GITDM API
 * Description here.
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query'
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query'
import * as axios from 'axios';
import type {
  AxiosError,
  AxiosRequestConfig,
  AxiosResponse
} from 'axios'
import type {
  AISummary,
  AISummaryList,
  ClinicalReference,
  CreateAISummary,
  Encounter,
  LabResult,
  MedicationOrder,
  PatchedAISummary,
  PatchedClinicalReference,
  PatchedEncounter,
  PatchedLabResult,
  PatchedMedicationOrder,
  PatchedPatient,
  Patient,
  RegenerateAISummary,
  TokenObtainPair,
  TokenRefresh
} from './gitdmApi.schemas'

// https://stackoverflow.com/questions/49579094/typescript-conditional-types-filter-out-readonly-properties-pick-only-requir/49579497#49579497
type IfEquals<X, Y, A = X, B = never> = (<T>() => T extends X ? 1 : 2) extends <
T,
>() => T extends Y ? 1 : 2
? A
: B;

type WritableKeys<T> = {
[P in keyof T]-?: IfEquals<
  { [Q in P]: T[P] },
  { -readonly [Q in P]: T[P] },
  P
>;
}[keyof T];

type UnionToIntersection<U> =
  (U extends any ? (k: U)=>void : never) extends ((k: infer I)=>void) ? I : never;
type DistributeReadOnlyOverUnions<T> = T extends any ? NonReadonly<T> : never;

type Writable<T> = Pick<T, WritableKeys<T>>;
type NonReadonly<T> = [T] extends [UnionToIntersection<T>] ? {
  [P in keyof Writable<T>]: T[P] extends object
    ? NonReadonly<NonNullable<T[P]>>
    : T[P];
} : DistributeReadOnlyOverUnions<T>;



/**
 * List all AI summaries with optional filtering by patient
 * @summary List AI summaries
 */
export const apiAiSummariesList = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AISummaryList[]>> => {
    
    
    return axios.default.get(
      `/api/ai-summaries`,options
    );
  }


export const getApiAiSummariesListQueryKey = () => {
    return [`/api/ai-summaries`] as const;
    }

    
export const getApiAiSummariesListQueryOptions = <TData = Awaited<ReturnType<typeof apiAiSummariesList>>, TError = AxiosError<void>>( options?: { query?:Partial<UseQueryOptions<TData, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiAiSummariesListQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiAiSummariesList>>> = ({ signal }) => apiAiSummariesList({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<TData, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ApiAiSummariesListQueryResult = NonNullable<Awaited<ReturnType<typeof apiAiSummariesList>>>
export type ApiAiSummariesListQueryError = AxiosError<void>


export function useApiAiSummariesList<TData = Awaited<ReturnType<typeof apiAiSummariesList>>, TError = AxiosError<void>>(
  options: { query:Partial<UseQueryOptions<TData, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          TData,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiAiSummariesList<TData = Awaited<ReturnType<typeof apiAiSummariesList>>, TError = AxiosError<void>>(
  options?: { query?:Partial<UseQueryOptions<TData, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          TData,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiAiSummariesList<TData = Awaited<ReturnType<typeof apiAiSummariesList>>, TError = AxiosError<void>>(
  options?: { query?:Partial<UseQueryOptions<TData, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List AI summaries
 */

export function useApiAiSummariesList<TData = Awaited<ReturnType<typeof apiAiSummariesList>>, TError = AxiosError<void>>(
  options?: { query?:Partial<UseQueryOptions<TData, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getApiAiSummariesListQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Create a new AI summary using GapGPT/OpenAI
 * @summary Create AI summary
 */
export const apiAiSummariesCreate = (
    createAISummary: CreateAISummary, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CreateAISummary>> => {
    
    
    return axios.default.post(
      `/api/ai-summaries`,
      createAISummary,options
    );
  }



export const getApiAiSummariesCreateMutationOptions = <TData = Awaited<ReturnType<typeof apiAiSummariesCreate>>, TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: CreateAISummary}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['apiAiSummariesCreate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiAiSummariesCreate>>, {data: CreateAISummary}> = (props) => {
          const {data} = props ?? {};

          return  apiAiSummariesCreate(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: CreateAISummary}, TContext>}

    export type ApiAiSummariesCreateMutationResult = NonNullable<Awaited<ReturnType<typeof apiAiSummariesCreate>>>
    export type ApiAiSummariesCreateMutationBody = CreateAISummary
    export type ApiAiSummariesCreateMutationError = AxiosError<void>

    /**
 * @summary Create AI summary
 */
export const useApiAiSummariesCreate = <TData = Awaited<ReturnType<typeof apiAiSummariesCreate>>, TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: CreateAISummary}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {data: CreateAISummary},
        TContext
      > => {

      const mutationOptions = getApiAiSummariesCreateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Retrieve a specific AI summary by ID
 * @summary Get AI summary
 */
export const apiAiSummariesRetrieve = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AISummary>> => {
    
    
    return axios.default.get(
      `/api/ai-summaries/${id}`,options
    );
  }


export const getApiAiSummariesRetrieveQueryKey = (id: number,) => {
    return [`/api/ai-summaries/${id}`] as const;
    }

    
export const getApiAiSummariesRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof apiAiSummariesRetrieve>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseQueryOptions<TData, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiAiSummariesRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiAiSummariesRetrieve>>> = ({ signal }) => apiAiSummariesRetrieve(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<TData, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ApiAiSummariesRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof apiAiSummariesRetrieve>>>
export type ApiAiSummariesRetrieveQueryError = AxiosError<void>


export function useApiAiSummariesRetrieve<TData = Awaited<ReturnType<typeof apiAiSummariesRetrieve>>, TError = AxiosError<void>>(
 id: number, options: { query:Partial<UseQueryOptions<TData, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          TData,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiAiSummariesRetrieve<TData = Awaited<ReturnType<typeof apiAiSummariesRetrieve>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<TData, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          TData,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiAiSummariesRetrieve<TData = Awaited<ReturnType<typeof apiAiSummariesRetrieve>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<TData, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get AI summary
 */

export function useApiAiSummariesRetrieve<TData = Awaited<ReturnType<typeof apiAiSummariesRetrieve>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<TData, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getApiAiSummariesRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * ViewSet for AI summaries with GapGPT/OpenAI integration
 * @summary Update AI summary
 */
export const apiAiSummariesUpdate = (
    id: number,
    aISummary: NonReadonly<AISummary>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AISummary>> => {
    
    
    return axios.default.put(
      `/api/ai-summaries/${id}`,
      aISummary,options
    );
  }



export const getApiAiSummariesUpdateMutationOptions = <TData = Awaited<ReturnType<typeof apiAiSummariesUpdate>>, TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: NonReadonly<AISummary>}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['apiAiSummariesUpdate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiAiSummariesUpdate>>, {id: number;data: NonReadonly<AISummary>}> = (props) => {
          const {id,data} = props ?? {};

          return  apiAiSummariesUpdate(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: NonReadonly<AISummary>}, TContext>}

    export type ApiAiSummariesUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof apiAiSummariesUpdate>>>
    export type ApiAiSummariesUpdateMutationBody = NonReadonly<AISummary>
    export type ApiAiSummariesUpdateMutationError = AxiosError<void>

    /**
 * @summary Update AI summary
 */
export const useApiAiSummariesUpdate = <TData = Awaited<ReturnType<typeof apiAiSummariesUpdate>>, TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: NonReadonly<AISummary>}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number;data: NonReadonly<AISummary>},
        TContext
      > => {

      const mutationOptions = getApiAiSummariesUpdateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * ViewSet for AI summaries with GapGPT/OpenAI integration
 * @summary Partially update AI summary
 */
export const apiAiSummariesPartialUpdate = (
    id: number,
    patchedAISummary: NonReadonly<PatchedAISummary>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AISummary>> => {
    
    
    return axios.default.patch(
      `/api/ai-summaries/${id}`,
      patchedAISummary,options
    );
  }



export const getApiAiSummariesPartialUpdateMutationOptions = <TData = Awaited<ReturnType<typeof apiAiSummariesPartialUpdate>>, TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: NonReadonly<PatchedAISummary>}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['apiAiSummariesPartialUpdate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiAiSummariesPartialUpdate>>, {id: number;data: NonReadonly<PatchedAISummary>}> = (props) => {
          const {id,data} = props ?? {};

          return  apiAiSummariesPartialUpdate(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: NonReadonly<PatchedAISummary>}, TContext>}

    export type ApiAiSummariesPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof apiAiSummariesPartialUpdate>>>
    export type ApiAiSummariesPartialUpdateMutationBody = NonReadonly<PatchedAISummary>
    export type ApiAiSummariesPartialUpdateMutationError = AxiosError<void>

    /**
 * @summary Partially update AI summary
 */
export const useApiAiSummariesPartialUpdate = <TData = Awaited<ReturnType<typeof apiAiSummariesPartialUpdate>>, TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: NonReadonly<PatchedAISummary>}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number;data: NonReadonly<PatchedAISummary>},
        TContext
      > => {

      const mutationOptions = getApiAiSummariesPartialUpdateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete an AI summary
 * @summary Delete AI summary
 */
export const apiAiSummariesDestroy = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.default.delete(
      `/api/ai-summaries/${id}`,options
    );
  }



export const getApiAiSummariesDestroyMutationOptions = <TData = Awaited<ReturnType<typeof apiAiSummariesDestroy>>, TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['apiAiSummariesDestroy'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiAiSummariesDestroy>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  apiAiSummariesDestroy(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type ApiAiSummariesDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof apiAiSummariesDestroy>>>
    
    export type ApiAiSummariesDestroyMutationError = AxiosError<void>

    /**
 * @summary Delete AI summary
 */
export const useApiAiSummariesDestroy = <TData = Awaited<ReturnType<typeof apiAiSummariesDestroy>>, TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getApiAiSummariesDestroyMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Regenerate AI summary for existing record with new content
 * @summary Regenerate AI summary
 */
export const apiAiSummariesRegenerateCreate = (
    id: number,
    regenerateAISummary: RegenerateAISummary, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AISummary>> => {
    
    
    return axios.default.post(
      `/api/ai-summaries/${id}/regenerate`,
      regenerateAISummary,options
    );
  }



export const getApiAiSummariesRegenerateCreateMutationOptions = <TData = Awaited<ReturnType<typeof apiAiSummariesRegenerateCreate>>, TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: RegenerateAISummary}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['apiAiSummariesRegenerateCreate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiAiSummariesRegenerateCreate>>, {id: number;data: RegenerateAISummary}> = (props) => {
          const {id,data} = props ?? {};

          return  apiAiSummariesRegenerateCreate(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: RegenerateAISummary}, TContext>}

    export type ApiAiSummariesRegenerateCreateMutationResult = NonNullable<Awaited<ReturnType<typeof apiAiSummariesRegenerateCreate>>>
    export type ApiAiSummariesRegenerateCreateMutationBody = RegenerateAISummary
    export type ApiAiSummariesRegenerateCreateMutationError = AxiosError<void>

    /**
 * @summary Regenerate AI summary
 */
export const useApiAiSummariesRegenerateCreate = <TData = Awaited<ReturnType<typeof apiAiSummariesRegenerateCreate>>, TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: RegenerateAISummary}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number;data: RegenerateAISummary},
        TContext
      > => {

      const mutationOptions = getApiAiSummariesRegenerateCreateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get statistics about AI summaries
 * @summary Get summary statistics
 */
export const apiAiSummariesStatsRetrieve = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AISummary>> => {
    
    
    return axios.default.get(
      `/api/ai-summaries/stats`,options
    );
  }


export const getApiAiSummariesStatsRetrieveQueryKey = () => {
    return [`/api/ai-summaries/stats`] as const;
    }

    
export const getApiAiSummariesStatsRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof apiAiSummariesStatsRetrieve>>, TError = AxiosError<void>>( options?: { query?:Partial<UseQueryOptions<TData, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiAiSummariesStatsRetrieveQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiAiSummariesStatsRetrieve>>> = ({ signal }) => apiAiSummariesStatsRetrieve({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<TData, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ApiAiSummariesStatsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof apiAiSummariesStatsRetrieve>>>
export type ApiAiSummariesStatsRetrieveQueryError = AxiosError<void>


export function useApiAiSummariesStatsRetrieve<TData = Awaited<ReturnType<typeof apiAiSummariesStatsRetrieve>>, TError = AxiosError<void>>(
  options: { query:Partial<UseQueryOptions<TData, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          TData,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiAiSummariesStatsRetrieve<TData = Awaited<ReturnType<typeof apiAiSummariesStatsRetrieve>>, TError = AxiosError<void>>(
  options?: { query?:Partial<UseQueryOptions<TData, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          TData,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiAiSummariesStatsRetrieve<TData = Awaited<ReturnType<typeof apiAiSummariesStatsRetrieve>>, TError = AxiosError<void>>(
  options?: { query?:Partial<UseQueryOptions<TData, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get summary statistics
 */

export function useApiAiSummariesStatsRetrieve<TData = Awaited<ReturnType<typeof apiAiSummariesStatsRetrieve>>, TError = AxiosError<void>>(
  options?: { query?:Partial<UseQueryOptions<TData, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getApiAiSummariesStatsRetrieveQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Test the AI service connection and generate a simple summary
 * @summary Test AI service
 */
export const apiAiSummariesTestCreate = (
    aISummary: NonReadonly<AISummary>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AISummary>> => {
    
    
    return axios.default.post(
      `/api/ai-summaries/test`,
      aISummary,options
    );
  }



export const getApiAiSummariesTestCreateMutationOptions = <TData = Awaited<ReturnType<typeof apiAiSummariesTestCreate>>, TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: NonReadonly<AISummary>}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['apiAiSummariesTestCreate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiAiSummariesTestCreate>>, {data: NonReadonly<AISummary>}> = (props) => {
          const {data} = props ?? {};

          return  apiAiSummariesTestCreate(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: NonReadonly<AISummary>}, TContext>}

    export type ApiAiSummariesTestCreateMutationResult = NonNullable<Awaited<ReturnType<typeof apiAiSummariesTestCreate>>>
    export type ApiAiSummariesTestCreateMutationBody = NonReadonly<AISummary>
    export type ApiAiSummariesTestCreateMutationError = AxiosError<void>

    /**
 * @summary Test AI service
 */
export const useApiAiSummariesTestCreate = <TData = Awaited<ReturnType<typeof apiAiSummariesTestCreate>>, TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: NonReadonly<AISummary>}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {data: NonReadonly<AISummary>},
        TContext
      > => {

      const mutationOptions = getApiAiSummariesTestCreateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Test the clinical references linking function with sample text
 * @summary Test clinical references linking
 */
export const apiAiSummariesTestReferencesCreate = (
    aISummary: NonReadonly<AISummary>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AISummary>> => {
    
    
    return axios.default.post(
      `/api/ai-summaries/test-references`,
      aISummary,options
    );
  }



export const getApiAiSummariesTestReferencesCreateMutationOptions = <TData = Awaited<ReturnType<typeof apiAiSummariesTestReferencesCreate>>, TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: NonReadonly<AISummary>}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['apiAiSummariesTestReferencesCreate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiAiSummariesTestReferencesCreate>>, {data: NonReadonly<AISummary>}> = (props) => {
          const {data} = props ?? {};

          return  apiAiSummariesTestReferencesCreate(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: NonReadonly<AISummary>}, TContext>}

    export type ApiAiSummariesTestReferencesCreateMutationResult = NonNullable<Awaited<ReturnType<typeof apiAiSummariesTestReferencesCreate>>>
    export type ApiAiSummariesTestReferencesCreateMutationBody = NonReadonly<AISummary>
    export type ApiAiSummariesTestReferencesCreateMutationError = AxiosError<void>

    /**
 * @summary Test clinical references linking
 */
export const useApiAiSummariesTestReferencesCreate = <TData = Awaited<ReturnType<typeof apiAiSummariesTestReferencesCreate>>, TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: NonReadonly<AISummary>}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {data: NonReadonly<AISummary>},
        TContext
      > => {

      const mutationOptions = getApiAiSummariesTestReferencesCreateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Takes a set of user credentials and returns an access and refresh JSON web
token pair to prove the authentication of those credentials.
 * @summary Obtain JWT token pair
 */
export const apiApiTokenCreate = (
    tokenObtainPair: NonReadonly<TokenObtainPair>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TokenObtainPair>> => {
    
    
    return axios.default.post(
      `/api/api/token`,
      tokenObtainPair,options
    );
  }



export const getApiApiTokenCreateMutationOptions = <TData = Awaited<ReturnType<typeof apiApiTokenCreate>>, TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: NonReadonly<TokenObtainPair>}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['apiApiTokenCreate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiApiTokenCreate>>, {data: NonReadonly<TokenObtainPair>}> = (props) => {
          const {data} = props ?? {};

          return  apiApiTokenCreate(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: NonReadonly<TokenObtainPair>}, TContext>}

    export type ApiApiTokenCreateMutationResult = NonNullable<Awaited<ReturnType<typeof apiApiTokenCreate>>>
    export type ApiApiTokenCreateMutationBody = NonReadonly<TokenObtainPair>
    export type ApiApiTokenCreateMutationError = AxiosError<void>

    /**
 * @summary Obtain JWT token pair
 */
export const useApiApiTokenCreate = <TData = Awaited<ReturnType<typeof apiApiTokenCreate>>, TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: NonReadonly<TokenObtainPair>}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {data: NonReadonly<TokenObtainPair>},
        TContext
      > => {

      const mutationOptions = getApiApiTokenCreateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Takes a refresh type JSON web token and returns an access type JSON web
token if the refresh token is valid.
 * @summary Refresh JWT access token
 */
export const apiApiTokenRefreshCreate = (
    tokenRefresh: NonReadonly<TokenRefresh>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TokenRefresh>> => {
    
    
    return axios.default.post(
      `/api/api/token/refresh`,
      tokenRefresh,options
    );
  }



export const getApiApiTokenRefreshCreateMutationOptions = <TData = Awaited<ReturnType<typeof apiApiTokenRefreshCreate>>, TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: NonReadonly<TokenRefresh>}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['apiApiTokenRefreshCreate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiApiTokenRefreshCreate>>, {data: NonReadonly<TokenRefresh>}> = (props) => {
          const {data} = props ?? {};

          return  apiApiTokenRefreshCreate(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: NonReadonly<TokenRefresh>}, TContext>}

    export type ApiApiTokenRefreshCreateMutationResult = NonNullable<Awaited<ReturnType<typeof apiApiTokenRefreshCreate>>>
    export type ApiApiTokenRefreshCreateMutationBody = NonReadonly<TokenRefresh>
    export type ApiApiTokenRefreshCreateMutationError = AxiosError<void>

    /**
 * @summary Refresh JWT access token
 */
export const useApiApiTokenRefreshCreate = <TData = Awaited<ReturnType<typeof apiApiTokenRefreshCreate>>, TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: NonReadonly<TokenRefresh>}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {data: NonReadonly<TokenRefresh>},
        TContext
      > => {

      const mutationOptions = getApiApiTokenRefreshCreateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary List encounters
 */
export const apiEncountersList = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Encounter[]>> => {
    
    
    return axios.default.get(
      `/api/encounters`,options
    );
  }


export const getApiEncountersListQueryKey = () => {
    return [`/api/encounters`] as const;
    }

    
export const getApiEncountersListQueryOptions = <TData = Awaited<ReturnType<typeof apiEncountersList>>, TError = AxiosError<void>>( options?: { query?:Partial<UseQueryOptions<TData, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiEncountersListQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiEncountersList>>> = ({ signal }) => apiEncountersList({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<TData, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ApiEncountersListQueryResult = NonNullable<Awaited<ReturnType<typeof apiEncountersList>>>
export type ApiEncountersListQueryError = AxiosError<void>


export function useApiEncountersList<TData = Awaited<ReturnType<typeof apiEncountersList>>, TError = AxiosError<void>>(
  options: { query:Partial<UseQueryOptions<TData, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          TData,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiEncountersList<TData = Awaited<ReturnType<typeof apiEncountersList>>, TError = AxiosError<void>>(
  options?: { query?:Partial<UseQueryOptions<TData, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          TData,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiEncountersList<TData = Awaited<ReturnType<typeof apiEncountersList>>, TError = AxiosError<void>>(
  options?: { query?:Partial<UseQueryOptions<TData, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List encounters
 */

export function useApiEncountersList<TData = Awaited<ReturnType<typeof apiEncountersList>>, TError = AxiosError<void>>(
  options?: { query?:Partial<UseQueryOptions<TData, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getApiEncountersListQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Create encounter
 */
export const apiEncountersCreate = (
    encounter: NonReadonly<Encounter>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Encounter>> => {
    
    
    return axios.default.post(
      `/api/encounters`,
      encounter,options
    );
  }



export const getApiEncountersCreateMutationOptions = <TData = Awaited<ReturnType<typeof apiEncountersCreate>>, TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: NonReadonly<Encounter>}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['apiEncountersCreate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiEncountersCreate>>, {data: NonReadonly<Encounter>}> = (props) => {
          const {data} = props ?? {};

          return  apiEncountersCreate(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: NonReadonly<Encounter>}, TContext>}

    export type ApiEncountersCreateMutationResult = NonNullable<Awaited<ReturnType<typeof apiEncountersCreate>>>
    export type ApiEncountersCreateMutationBody = NonReadonly<Encounter>
    export type ApiEncountersCreateMutationError = AxiosError<void>

    /**
 * @summary Create encounter
 */
export const useApiEncountersCreate = <TData = Awaited<ReturnType<typeof apiEncountersCreate>>, TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: NonReadonly<Encounter>}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {data: NonReadonly<Encounter>},
        TContext
      > => {

      const mutationOptions = getApiEncountersCreateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get encounter
 */
export const apiEncountersRetrieve = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Encounter>> => {
    
    
    return axios.default.get(
      `/api/encounters/${id}`,options
    );
  }


export const getApiEncountersRetrieveQueryKey = (id: number,) => {
    return [`/api/encounters/${id}`] as const;
    }

    
export const getApiEncountersRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof apiEncountersRetrieve>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseQueryOptions<TData, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiEncountersRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiEncountersRetrieve>>> = ({ signal }) => apiEncountersRetrieve(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<TData, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ApiEncountersRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof apiEncountersRetrieve>>>
export type ApiEncountersRetrieveQueryError = AxiosError<void>


export function useApiEncountersRetrieve<TData = Awaited<ReturnType<typeof apiEncountersRetrieve>>, TError = AxiosError<void>>(
 id: number, options: { query:Partial<UseQueryOptions<TData, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          TData,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiEncountersRetrieve<TData = Awaited<ReturnType<typeof apiEncountersRetrieve>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<TData, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          TData,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiEncountersRetrieve<TData = Awaited<ReturnType<typeof apiEncountersRetrieve>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<TData, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get encounter
 */

export function useApiEncountersRetrieve<TData = Awaited<ReturnType<typeof apiEncountersRetrieve>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<TData, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getApiEncountersRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Update encounter
 */
export const apiEncountersUpdate = (
    id: number,
    encounter: NonReadonly<Encounter>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Encounter>> => {
    
    
    return axios.default.put(
      `/api/encounters/${id}`,
      encounter,options
    );
  }



export const getApiEncountersUpdateMutationOptions = <TData = Awaited<ReturnType<typeof apiEncountersUpdate>>, TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: NonReadonly<Encounter>}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['apiEncountersUpdate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiEncountersUpdate>>, {id: number;data: NonReadonly<Encounter>}> = (props) => {
          const {id,data} = props ?? {};

          return  apiEncountersUpdate(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: NonReadonly<Encounter>}, TContext>}

    export type ApiEncountersUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof apiEncountersUpdate>>>
    export type ApiEncountersUpdateMutationBody = NonReadonly<Encounter>
    export type ApiEncountersUpdateMutationError = AxiosError<void>

    /**
 * @summary Update encounter
 */
export const useApiEncountersUpdate = <TData = Awaited<ReturnType<typeof apiEncountersUpdate>>, TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: NonReadonly<Encounter>}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number;data: NonReadonly<Encounter>},
        TContext
      > => {

      const mutationOptions = getApiEncountersUpdateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Partially update encounter
 */
export const apiEncountersPartialUpdate = (
    id: number,
    patchedEncounter: NonReadonly<PatchedEncounter>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Encounter>> => {
    
    
    return axios.default.patch(
      `/api/encounters/${id}`,
      patchedEncounter,options
    );
  }



export const getApiEncountersPartialUpdateMutationOptions = <TData = Awaited<ReturnType<typeof apiEncountersPartialUpdate>>, TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: NonReadonly<PatchedEncounter>}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['apiEncountersPartialUpdate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiEncountersPartialUpdate>>, {id: number;data: NonReadonly<PatchedEncounter>}> = (props) => {
          const {id,data} = props ?? {};

          return  apiEncountersPartialUpdate(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: NonReadonly<PatchedEncounter>}, TContext>}

    export type ApiEncountersPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof apiEncountersPartialUpdate>>>
    export type ApiEncountersPartialUpdateMutationBody = NonReadonly<PatchedEncounter>
    export type ApiEncountersPartialUpdateMutationError = AxiosError<void>

    /**
 * @summary Partially update encounter
 */
export const useApiEncountersPartialUpdate = <TData = Awaited<ReturnType<typeof apiEncountersPartialUpdate>>, TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: NonReadonly<PatchedEncounter>}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number;data: NonReadonly<PatchedEncounter>},
        TContext
      > => {

      const mutationOptions = getApiEncountersPartialUpdateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Delete encounter
 */
export const apiEncountersDestroy = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.default.delete(
      `/api/encounters/${id}`,options
    );
  }



export const getApiEncountersDestroyMutationOptions = <TData = Awaited<ReturnType<typeof apiEncountersDestroy>>, TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['apiEncountersDestroy'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiEncountersDestroy>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  apiEncountersDestroy(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type ApiEncountersDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof apiEncountersDestroy>>>
    
    export type ApiEncountersDestroyMutationError = AxiosError<void>

    /**
 * @summary Delete encounter
 */
export const useApiEncountersDestroy = <TData = Awaited<ReturnType<typeof apiEncountersDestroy>>, TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getApiEncountersDestroyMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary List lab results
 */
export const apiLabsList = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<LabResult[]>> => {
    
    
    return axios.default.get(
      `/api/labs`,options
    );
  }


export const getApiLabsListQueryKey = () => {
    return [`/api/labs`] as const;
    }

    
export const getApiLabsListQueryOptions = <TData = Awaited<ReturnType<typeof apiLabsList>>, TError = AxiosError<void>>( options?: { query?:Partial<UseQueryOptions<TData, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiLabsListQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiLabsList>>> = ({ signal }) => apiLabsList({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<TData, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ApiLabsListQueryResult = NonNullable<Awaited<ReturnType<typeof apiLabsList>>>
export type ApiLabsListQueryError = AxiosError<void>


export function useApiLabsList<TData = Awaited<ReturnType<typeof apiLabsList>>, TError = AxiosError<void>>(
  options: { query:Partial<UseQueryOptions<TData, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          TData,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiLabsList<TData = Awaited<ReturnType<typeof apiLabsList>>, TError = AxiosError<void>>(
  options?: { query?:Partial<UseQueryOptions<TData, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          TData,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiLabsList<TData = Awaited<ReturnType<typeof apiLabsList>>, TError = AxiosError<void>>(
  options?: { query?:Partial<UseQueryOptions<TData, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List lab results
 */

export function useApiLabsList<TData = Awaited<ReturnType<typeof apiLabsList>>, TError = AxiosError<void>>(
  options?: { query?:Partial<UseQueryOptions<TData, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getApiLabsListQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Create lab result
 */
export const apiLabsCreate = (
    labResult: NonReadonly<LabResult>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<LabResult>> => {
    
    
    return axios.default.post(
      `/api/labs`,
      labResult,options
    );
  }



export const getApiLabsCreateMutationOptions = <TData = Awaited<ReturnType<typeof apiLabsCreate>>, TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: NonReadonly<LabResult>}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['apiLabsCreate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiLabsCreate>>, {data: NonReadonly<LabResult>}> = (props) => {
          const {data} = props ?? {};

          return  apiLabsCreate(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: NonReadonly<LabResult>}, TContext>}

    export type ApiLabsCreateMutationResult = NonNullable<Awaited<ReturnType<typeof apiLabsCreate>>>
    export type ApiLabsCreateMutationBody = NonReadonly<LabResult>
    export type ApiLabsCreateMutationError = AxiosError<void>

    /**
 * @summary Create lab result
 */
export const useApiLabsCreate = <TData = Awaited<ReturnType<typeof apiLabsCreate>>, TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: NonReadonly<LabResult>}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {data: NonReadonly<LabResult>},
        TContext
      > => {

      const mutationOptions = getApiLabsCreateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get lab result
 */
export const apiLabsRetrieve = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<LabResult>> => {
    
    
    return axios.default.get(
      `/api/labs/${id}`,options
    );
  }


export const getApiLabsRetrieveQueryKey = (id: number,) => {
    return [`/api/labs/${id}`] as const;
    }

    
export const getApiLabsRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof apiLabsRetrieve>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseQueryOptions<TData, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiLabsRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiLabsRetrieve>>> = ({ signal }) => apiLabsRetrieve(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<TData, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ApiLabsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof apiLabsRetrieve>>>
export type ApiLabsRetrieveQueryError = AxiosError<void>


export function useApiLabsRetrieve<TData = Awaited<ReturnType<typeof apiLabsRetrieve>>, TError = AxiosError<void>>(
 id: number, options: { query:Partial<UseQueryOptions<TData, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          TData,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiLabsRetrieve<TData = Awaited<ReturnType<typeof apiLabsRetrieve>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<TData, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          TData,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiLabsRetrieve<TData = Awaited<ReturnType<typeof apiLabsRetrieve>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<TData, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get lab result
 */

export function useApiLabsRetrieve<TData = Awaited<ReturnType<typeof apiLabsRetrieve>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<TData, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getApiLabsRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Update lab result
 */
export const apiLabsUpdate = (
    id: number,
    labResult: NonReadonly<LabResult>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<LabResult>> => {
    
    
    return axios.default.put(
      `/api/labs/${id}`,
      labResult,options
    );
  }



export const getApiLabsUpdateMutationOptions = <TData = Awaited<ReturnType<typeof apiLabsUpdate>>, TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: NonReadonly<LabResult>}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['apiLabsUpdate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiLabsUpdate>>, {id: number;data: NonReadonly<LabResult>}> = (props) => {
          const {id,data} = props ?? {};

          return  apiLabsUpdate(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: NonReadonly<LabResult>}, TContext>}

    export type ApiLabsUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof apiLabsUpdate>>>
    export type ApiLabsUpdateMutationBody = NonReadonly<LabResult>
    export type ApiLabsUpdateMutationError = AxiosError<void>

    /**
 * @summary Update lab result
 */
export const useApiLabsUpdate = <TData = Awaited<ReturnType<typeof apiLabsUpdate>>, TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: NonReadonly<LabResult>}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number;data: NonReadonly<LabResult>},
        TContext
      > => {

      const mutationOptions = getApiLabsUpdateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Partially update lab result
 */
export const apiLabsPartialUpdate = (
    id: number,
    patchedLabResult: NonReadonly<PatchedLabResult>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<LabResult>> => {
    
    
    return axios.default.patch(
      `/api/labs/${id}`,
      patchedLabResult,options
    );
  }



export const getApiLabsPartialUpdateMutationOptions = <TData = Awaited<ReturnType<typeof apiLabsPartialUpdate>>, TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: NonReadonly<PatchedLabResult>}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['apiLabsPartialUpdate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiLabsPartialUpdate>>, {id: number;data: NonReadonly<PatchedLabResult>}> = (props) => {
          const {id,data} = props ?? {};

          return  apiLabsPartialUpdate(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: NonReadonly<PatchedLabResult>}, TContext>}

    export type ApiLabsPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof apiLabsPartialUpdate>>>
    export type ApiLabsPartialUpdateMutationBody = NonReadonly<PatchedLabResult>
    export type ApiLabsPartialUpdateMutationError = AxiosError<void>

    /**
 * @summary Partially update lab result
 */
export const useApiLabsPartialUpdate = <TData = Awaited<ReturnType<typeof apiLabsPartialUpdate>>, TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: NonReadonly<PatchedLabResult>}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number;data: NonReadonly<PatchedLabResult>},
        TContext
      > => {

      const mutationOptions = getApiLabsPartialUpdateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Delete lab result
 */
export const apiLabsDestroy = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.default.delete(
      `/api/labs/${id}`,options
    );
  }



export const getApiLabsDestroyMutationOptions = <TData = Awaited<ReturnType<typeof apiLabsDestroy>>, TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['apiLabsDestroy'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiLabsDestroy>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  apiLabsDestroy(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type ApiLabsDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof apiLabsDestroy>>>
    
    export type ApiLabsDestroyMutationError = AxiosError<void>

    /**
 * @summary Delete lab result
 */
export const useApiLabsDestroy = <TData = Awaited<ReturnType<typeof apiLabsDestroy>>, TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getApiLabsDestroyMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary List medication orders
 */
export const apiMedsList = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<MedicationOrder[]>> => {
    
    
    return axios.default.get(
      `/api/meds`,options
    );
  }


export const getApiMedsListQueryKey = () => {
    return [`/api/meds`] as const;
    }

    
export const getApiMedsListQueryOptions = <TData = Awaited<ReturnType<typeof apiMedsList>>, TError = AxiosError<void>>( options?: { query?:Partial<UseQueryOptions<TData, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiMedsListQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiMedsList>>> = ({ signal }) => apiMedsList({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<TData, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ApiMedsListQueryResult = NonNullable<Awaited<ReturnType<typeof apiMedsList>>>
export type ApiMedsListQueryError = AxiosError<void>


export function useApiMedsList<TData = Awaited<ReturnType<typeof apiMedsList>>, TError = AxiosError<void>>(
  options: { query:Partial<UseQueryOptions<TData, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          TData,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiMedsList<TData = Awaited<ReturnType<typeof apiMedsList>>, TError = AxiosError<void>>(
  options?: { query?:Partial<UseQueryOptions<TData, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          TData,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiMedsList<TData = Awaited<ReturnType<typeof apiMedsList>>, TError = AxiosError<void>>(
  options?: { query?:Partial<UseQueryOptions<TData, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List medication orders
 */

export function useApiMedsList<TData = Awaited<ReturnType<typeof apiMedsList>>, TError = AxiosError<void>>(
  options?: { query?:Partial<UseQueryOptions<TData, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getApiMedsListQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Create medication order
 */
export const apiMedsCreate = (
    medicationOrder: NonReadonly<MedicationOrder>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<MedicationOrder>> => {
    
    
    return axios.default.post(
      `/api/meds`,
      medicationOrder,options
    );
  }



export const getApiMedsCreateMutationOptions = <TData = Awaited<ReturnType<typeof apiMedsCreate>>, TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: NonReadonly<MedicationOrder>}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['apiMedsCreate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiMedsCreate>>, {data: NonReadonly<MedicationOrder>}> = (props) => {
          const {data} = props ?? {};

          return  apiMedsCreate(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: NonReadonly<MedicationOrder>}, TContext>}

    export type ApiMedsCreateMutationResult = NonNullable<Awaited<ReturnType<typeof apiMedsCreate>>>
    export type ApiMedsCreateMutationBody = NonReadonly<MedicationOrder>
    export type ApiMedsCreateMutationError = AxiosError<void>

    /**
 * @summary Create medication order
 */
export const useApiMedsCreate = <TData = Awaited<ReturnType<typeof apiMedsCreate>>, TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: NonReadonly<MedicationOrder>}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {data: NonReadonly<MedicationOrder>},
        TContext
      > => {

      const mutationOptions = getApiMedsCreateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get medication order
 */
export const apiMedsRetrieve = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<MedicationOrder>> => {
    
    
    return axios.default.get(
      `/api/meds/${id}`,options
    );
  }


export const getApiMedsRetrieveQueryKey = (id: number,) => {
    return [`/api/meds/${id}`] as const;
    }

    
export const getApiMedsRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof apiMedsRetrieve>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseQueryOptions<TData, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiMedsRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiMedsRetrieve>>> = ({ signal }) => apiMedsRetrieve(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<TData, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ApiMedsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof apiMedsRetrieve>>>
export type ApiMedsRetrieveQueryError = AxiosError<void>


export function useApiMedsRetrieve<TData = Awaited<ReturnType<typeof apiMedsRetrieve>>, TError = AxiosError<void>>(
 id: number, options: { query:Partial<UseQueryOptions<TData, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          TData,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiMedsRetrieve<TData = Awaited<ReturnType<typeof apiMedsRetrieve>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<TData, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          TData,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiMedsRetrieve<TData = Awaited<ReturnType<typeof apiMedsRetrieve>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<TData, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get medication order
 */

export function useApiMedsRetrieve<TData = Awaited<ReturnType<typeof apiMedsRetrieve>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<TData, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getApiMedsRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Update medication order
 */
export const apiMedsUpdate = (
    id: number,
    medicationOrder: NonReadonly<MedicationOrder>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<MedicationOrder>> => {
    
    
    return axios.default.put(
      `/api/meds/${id}`,
      medicationOrder,options
    );
  }



export const getApiMedsUpdateMutationOptions = <TData = Awaited<ReturnType<typeof apiMedsUpdate>>, TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: NonReadonly<MedicationOrder>}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['apiMedsUpdate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiMedsUpdate>>, {id: number;data: NonReadonly<MedicationOrder>}> = (props) => {
          const {id,data} = props ?? {};

          return  apiMedsUpdate(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: NonReadonly<MedicationOrder>}, TContext>}

    export type ApiMedsUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof apiMedsUpdate>>>
    export type ApiMedsUpdateMutationBody = NonReadonly<MedicationOrder>
    export type ApiMedsUpdateMutationError = AxiosError<void>

    /**
 * @summary Update medication order
 */
export const useApiMedsUpdate = <TData = Awaited<ReturnType<typeof apiMedsUpdate>>, TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: NonReadonly<MedicationOrder>}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number;data: NonReadonly<MedicationOrder>},
        TContext
      > => {

      const mutationOptions = getApiMedsUpdateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Partially update medication order
 */
export const apiMedsPartialUpdate = (
    id: number,
    patchedMedicationOrder: NonReadonly<PatchedMedicationOrder>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<MedicationOrder>> => {
    
    
    return axios.default.patch(
      `/api/meds/${id}`,
      patchedMedicationOrder,options
    );
  }



export const getApiMedsPartialUpdateMutationOptions = <TData = Awaited<ReturnType<typeof apiMedsPartialUpdate>>, TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: NonReadonly<PatchedMedicationOrder>}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['apiMedsPartialUpdate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiMedsPartialUpdate>>, {id: number;data: NonReadonly<PatchedMedicationOrder>}> = (props) => {
          const {id,data} = props ?? {};

          return  apiMedsPartialUpdate(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: NonReadonly<PatchedMedicationOrder>}, TContext>}

    export type ApiMedsPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof apiMedsPartialUpdate>>>
    export type ApiMedsPartialUpdateMutationBody = NonReadonly<PatchedMedicationOrder>
    export type ApiMedsPartialUpdateMutationError = AxiosError<void>

    /**
 * @summary Partially update medication order
 */
export const useApiMedsPartialUpdate = <TData = Awaited<ReturnType<typeof apiMedsPartialUpdate>>, TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: NonReadonly<PatchedMedicationOrder>}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number;data: NonReadonly<PatchedMedicationOrder>},
        TContext
      > => {

      const mutationOptions = getApiMedsPartialUpdateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Delete medication order
 */
export const apiMedsDestroy = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.default.delete(
      `/api/meds/${id}`,options
    );
  }



export const getApiMedsDestroyMutationOptions = <TData = Awaited<ReturnType<typeof apiMedsDestroy>>, TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['apiMedsDestroy'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiMedsDestroy>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  apiMedsDestroy(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type ApiMedsDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof apiMedsDestroy>>>
    
    export type ApiMedsDestroyMutationError = AxiosError<void>

    /**
 * @summary Delete medication order
 */
export const useApiMedsDestroy = <TData = Awaited<ReturnType<typeof apiMedsDestroy>>, TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getApiMedsDestroyMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary List patients
 */
export const apiPatientsList = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Patient[]>> => {
    
    
    return axios.default.get(
      `/api/patients`,options
    );
  }


export const getApiPatientsListQueryKey = () => {
    return [`/api/patients`] as const;
    }

    
export const getApiPatientsListQueryOptions = <TData = Awaited<ReturnType<typeof apiPatientsList>>, TError = AxiosError<void>>( options?: { query?:Partial<UseQueryOptions<TData, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiPatientsListQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiPatientsList>>> = ({ signal }) => apiPatientsList({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<TData, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ApiPatientsListQueryResult = NonNullable<Awaited<ReturnType<typeof apiPatientsList>>>
export type ApiPatientsListQueryError = AxiosError<void>


export function useApiPatientsList<TData = Awaited<ReturnType<typeof apiPatientsList>>, TError = AxiosError<void>>(
  options: { query:Partial<UseQueryOptions<TData, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          TData,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiPatientsList<TData = Awaited<ReturnType<typeof apiPatientsList>>, TError = AxiosError<void>>(
  options?: { query?:Partial<UseQueryOptions<TData, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          TData,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiPatientsList<TData = Awaited<ReturnType<typeof apiPatientsList>>, TError = AxiosError<void>>(
  options?: { query?:Partial<UseQueryOptions<TData, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List patients
 */

export function useApiPatientsList<TData = Awaited<ReturnType<typeof apiPatientsList>>, TError = AxiosError<void>>(
  options?: { query?:Partial<UseQueryOptions<TData, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getApiPatientsListQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Create patient
 */
export const apiPatientsCreate = (
    patient: NonReadonly<Patient>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Patient>> => {
    
    
    return axios.default.post(
      `/api/patients`,
      patient,options
    );
  }



export const getApiPatientsCreateMutationOptions = <TData = Awaited<ReturnType<typeof apiPatientsCreate>>, TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: NonReadonly<Patient>}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['apiPatientsCreate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiPatientsCreate>>, {data: NonReadonly<Patient>}> = (props) => {
          const {data} = props ?? {};

          return  apiPatientsCreate(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: NonReadonly<Patient>}, TContext>}

    export type ApiPatientsCreateMutationResult = NonNullable<Awaited<ReturnType<typeof apiPatientsCreate>>>
    export type ApiPatientsCreateMutationBody = NonReadonly<Patient>
    export type ApiPatientsCreateMutationError = AxiosError<void>

    /**
 * @summary Create patient
 */
export const useApiPatientsCreate = <TData = Awaited<ReturnType<typeof apiPatientsCreate>>, TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: NonReadonly<Patient>}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {data: NonReadonly<Patient>},
        TContext
      > => {

      const mutationOptions = getApiPatientsCreateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get patient
 */
export const apiPatientsRetrieve = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Patient>> => {
    
    
    return axios.default.get(
      `/api/patients/${id}`,options
    );
  }


export const getApiPatientsRetrieveQueryKey = (id: number,) => {
    return [`/api/patients/${id}`] as const;
    }

    
export const getApiPatientsRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof apiPatientsRetrieve>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseQueryOptions<TData, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiPatientsRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiPatientsRetrieve>>> = ({ signal }) => apiPatientsRetrieve(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<TData, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ApiPatientsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof apiPatientsRetrieve>>>
export type ApiPatientsRetrieveQueryError = AxiosError<void>


export function useApiPatientsRetrieve<TData = Awaited<ReturnType<typeof apiPatientsRetrieve>>, TError = AxiosError<void>>(
 id: number, options: { query:Partial<UseQueryOptions<TData, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          TData,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiPatientsRetrieve<TData = Awaited<ReturnType<typeof apiPatientsRetrieve>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<TData, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          TData,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiPatientsRetrieve<TData = Awaited<ReturnType<typeof apiPatientsRetrieve>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<TData, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get patient
 */

export function useApiPatientsRetrieve<TData = Awaited<ReturnType<typeof apiPatientsRetrieve>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<TData, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getApiPatientsRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Update patient
 */
export const apiPatientsUpdate = (
    id: number,
    patient: NonReadonly<Patient>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Patient>> => {
    
    
    return axios.default.put(
      `/api/patients/${id}`,
      patient,options
    );
  }



export const getApiPatientsUpdateMutationOptions = <TData = Awaited<ReturnType<typeof apiPatientsUpdate>>, TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: NonReadonly<Patient>}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['apiPatientsUpdate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiPatientsUpdate>>, {id: number;data: NonReadonly<Patient>}> = (props) => {
          const {id,data} = props ?? {};

          return  apiPatientsUpdate(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: NonReadonly<Patient>}, TContext>}

    export type ApiPatientsUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof apiPatientsUpdate>>>
    export type ApiPatientsUpdateMutationBody = NonReadonly<Patient>
    export type ApiPatientsUpdateMutationError = AxiosError<void>

    /**
 * @summary Update patient
 */
export const useApiPatientsUpdate = <TData = Awaited<ReturnType<typeof apiPatientsUpdate>>, TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: NonReadonly<Patient>}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number;data: NonReadonly<Patient>},
        TContext
      > => {

      const mutationOptions = getApiPatientsUpdateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Partially update patient
 */
export const apiPatientsPartialUpdate = (
    id: number,
    patchedPatient: NonReadonly<PatchedPatient>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Patient>> => {
    
    
    return axios.default.patch(
      `/api/patients/${id}`,
      patchedPatient,options
    );
  }



export const getApiPatientsPartialUpdateMutationOptions = <TData = Awaited<ReturnType<typeof apiPatientsPartialUpdate>>, TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: NonReadonly<PatchedPatient>}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['apiPatientsPartialUpdate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiPatientsPartialUpdate>>, {id: number;data: NonReadonly<PatchedPatient>}> = (props) => {
          const {id,data} = props ?? {};

          return  apiPatientsPartialUpdate(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: NonReadonly<PatchedPatient>}, TContext>}

    export type ApiPatientsPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof apiPatientsPartialUpdate>>>
    export type ApiPatientsPartialUpdateMutationBody = NonReadonly<PatchedPatient>
    export type ApiPatientsPartialUpdateMutationError = AxiosError<void>

    /**
 * @summary Partially update patient
 */
export const useApiPatientsPartialUpdate = <TData = Awaited<ReturnType<typeof apiPatientsPartialUpdate>>, TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: NonReadonly<PatchedPatient>}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number;data: NonReadonly<PatchedPatient>},
        TContext
      > => {

      const mutationOptions = getApiPatientsPartialUpdateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Delete patient
 */
export const apiPatientsDestroy = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.default.delete(
      `/api/patients/${id}`,options
    );
  }



export const getApiPatientsDestroyMutationOptions = <TData = Awaited<ReturnType<typeof apiPatientsDestroy>>, TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['apiPatientsDestroy'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiPatientsDestroy>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  apiPatientsDestroy(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type ApiPatientsDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof apiPatientsDestroy>>>
    
    export type ApiPatientsDestroyMutationError = AxiosError<void>

    /**
 * @summary Delete patient
 */
export const useApiPatientsDestroy = <TData = Awaited<ReturnType<typeof apiPatientsDestroy>>, TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getApiPatientsDestroyMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * ÿ™ÿß€åŸÖ‚ÄåŸÑÿß€åŸÜ ÿ™ÿ¨ŸÖ€åÿπ‚Äåÿ¥ÿØŸá €å⁄© ÿ®€åŸÖÿßÿ± ÿ±ÿß ÿ®ÿ±ŸÖ€å‚Äå⁄Øÿ±ÿØÿßŸÜÿØÿå ÿ¥ÿßŸÖŸÑ ŸÖŸàÿßÿ¨Ÿáÿßÿ™ ÿ®ÿßŸÑ€åŸÜ€åÿå ŸÜÿ™ÿß€åÿ¨ ÿ¢ÿ≤ŸÖÿß€åÿ¥ÿå ÿØÿ≥ÿ™Ÿàÿ±Ÿáÿß€å ÿØÿßÿ±Ÿà€å€å Ÿà ÿÆŸÑÿßÿµŸá‚ÄåŸáÿß€å ÿ™ŸàŸÑ€åÿØÿ¥ÿØŸá ÿ™Ÿàÿ≥ÿ∑ ÿ≤€åÿ±ÿ≥€åÿ≥ÿ™ŸÖ ŸáŸàÿ¥‚ÄåŸÖÿµŸÜŸàÿπ€å.

ÿ¨ÿ≤ÿ¶€åÿßÿ™:
- ÿß€åŸÜ ÿß⁄©ÿ¥ŸÜ ÿ®ÿ±ÿß€å €å⁄© ÿ®€åŸÖÿßÿ± ŸÖÿ¥ÿÆÿµ (ÿ®ÿ± Ÿæÿß€åŸá pk/URL) ÿßÿ¨ÿ±ÿß ŸÖ€å‚Äåÿ¥ŸàÿØ Ÿà ŸÖÿ¨ŸÖŸàÿπŸá‚ÄåŸáÿß€å ŸÖÿ±ÿ™ÿ®ÿ∑ ÿ±ÿß ÿ¨ÿØÿß⁄ØÿßŸÜŸá Ÿàÿß⁄©ÿ¥€å Ÿà ÿ≥ÿ±€åÿßŸÑÿß€åÿ≤ ŸÖ€å‚Äå⁄©ŸÜÿØ.
- ŸÖÿ≠ÿØŸàÿØ€åÿ™‚ÄåŸáÿß:
- Ÿæÿßÿ±ÿßŸÖÿ™ÿ± ⁄©Ÿàÿ¶ÿ±€å `limit` ÿ™ÿπ€å€åŸÜ‚Äå⁄©ŸÜŸÜÿØŸá ÿ≠ÿØÿß⁄©ÿ´ÿ± ÿ™ÿπÿØÿßÿØ ÿ¢€åÿ™ŸÖ‚ÄåŸáÿß ÿ®ÿ±ÿß€å Ÿáÿ± €å⁄© ÿßÿ≤ ŸÜŸàÿπ‚ÄåŸáÿß€å Encounterÿå LabResult Ÿà MedicationOrder ÿßÿ≥ÿ™. ŸÖŸÇÿØÿßÿ± Ÿæ€åÿ¥‚ÄåŸÅÿ±ÿ∂ 100 Ÿà ÿ®€åÿ¥€åŸÜŸá ŸÖÿ¨ÿßÿ≤ 500 ÿßÿ≥ÿ™ (ÿß⁄Øÿ± ŸÖŸÇÿØÿßÿ± ÿ®ÿ≤ÿ±⁄Ø‚Äåÿ™ÿ± ÿßÿ±ÿ≥ÿßŸÑ ÿ¥ŸàÿØ ÿ®Ÿá 500 ÿ™ŸÇŸÑ€åŸÑ ŸÖ€å‚Äå€åÿßÿ®ÿØ).
- AISummaryŸáÿß ŸÖÿ≥ÿ™ŸÇŸÑ ÿßÿ≤ `limit` ŸáŸÖŸàÿßÿ±Ÿá ÿ™ÿß 5 ŸÖŸàÿ±ÿØ ÿßÿÆ€åÿ± (ÿ®ÿ± ÿßÿ≥ÿßÿ≥ `created_at` ŸÜÿ≤ŸàŸÑ€å) ŸÖÿ≠ÿØŸàÿØ ŸÖ€å‚Äåÿ¥ŸàŸÜÿØ.
- ÿØÿßÿØŸá‚ÄåŸáÿß€å ÿ®ÿßÿ≤⁄Øÿ±ÿØÿßŸÜÿØŸá ÿ¥ÿØŸá:
- patient: ÿØÿßÿØŸá ÿ≥ÿ±€åÿßŸÑÿß€åÿ≤ÿ¥ÿØŸáŸî ÿ®€åŸÖÿßÿ±
- encounters: ŸÑ€åÿ≥ÿ™ ÿ≥ÿ±€åÿßŸÑÿß€åÿ≤ÿ¥ÿØŸáŸî EncounterŸáÿß ŸÖÿ±ÿ™ÿ®‚Äåÿ¥ÿØŸá ÿ®ÿ± ÿßÿ≥ÿßÿ≥ `occured_at` ŸÜÿ≤ŸàŸÑ€å (ÿ™ÿß `limit`)
- labs: ŸÑ€åÿ≥ÿ™ ÿ≥ÿ±€åÿßŸÑÿß€åÿ≤ÿ¥ÿØŸáŸî LabResultŸáÿß ŸÖÿ±ÿ™ÿ®‚Äåÿ¥ÿØŸá ÿ®ÿ± ÿßÿ≥ÿßÿ≥ `taken_at` ŸÜÿ≤ŸàŸÑ€å (ÿ™ÿß `limit`)
- medications: ŸÑ€åÿ≥ÿ™ ÿ≥ÿ±€åÿßŸÑÿß€åÿ≤ÿ¥ÿØŸáŸî MedicationOrderŸáÿß ŸÖÿ±ÿ™ÿ®‚Äåÿ¥ÿØŸá ÿ®ÿ± ÿßÿ≥ÿßÿ≥ `start_date` ŸÜÿ≤ŸàŸÑ€å (ÿ™ÿß `limit`)
- ai_summaries: ŸÑ€åÿ≥ÿ™ ÿ≥ÿ±€åÿßŸÑÿß€åÿ≤ÿ¥ÿØŸáŸî AISummaryŸáÿß (ÿ≠ÿØÿß⁄©ÿ´ÿ± 5 ŸÖŸàÿ±ÿØÿå ŸÖÿ±ÿ™ÿ® ÿ®ÿ± ÿßÿ≥ÿßÿ≥ `created_at` ŸÜÿ≤ŸàŸÑ€å)

ŸÜ⁄©ÿßÿ™ ŸÖÿ±ÿ™ÿ®ÿ∑ ÿ®ÿß ŸáŸàÿ¥‚ÄåŸÖÿµŸÜŸàÿπ€å Ÿà Ÿæÿ±ÿØÿßÿ≤ÿ¥:
- AISummaryŸáÿß ÿÆÿ±Ÿàÿ¨€å‚ÄåŸáÿß€å ÿ™ÿ≠ŸÑ€åŸÑ€å/ÿÆŸÑÿßÿµŸá‚Äåÿ≥ÿßÿ≤€å Ÿáÿ≥ÿ™ŸÜÿØ ⁄©Ÿá ŸÖŸÖ⁄©ŸÜ ÿßÿ≥ÿ™ ÿ®ÿ± Ÿæÿß€åŸá Ÿæÿ±ÿØÿßÿ≤ÿ¥‚ÄåŸáÿß€å ÿÆŸàÿØ⁄©ÿßÿ±ÿå ŸÖÿØŸÑ‚ÄåŸáÿß€å ÿ≤ÿ®ÿßŸÜ€å €åÿß ÿ¢ŸÜÿßŸÑ€åÿ≤Ÿáÿß€å ÿ®ÿßŸÑ€åŸÜ€å ÿ™ŸàŸÑ€åÿØ ÿ¥ÿØŸá ÿ®ÿßÿ¥ŸÜÿØÿõ ÿß€åŸÜ ŸÖŸàÿßÿ±ÿØ ŸÖ⁄©ŸÖŸÑ ÿØÿßÿØŸá‚ÄåŸáÿß€å ÿÆÿßŸÖ ÿ®ÿßŸÑ€åŸÜ€å Ÿáÿ≥ÿ™ŸÜÿØ Ÿà ÿ®ÿ±ÿß€å ŸÜŸÖÿß€åÿ¥ ÿÆŸÑÿßÿµŸáŸî Ÿàÿ∂ÿπ€åÿ™ €åÿß ŸÜ⁄©ÿßÿ™ ŸÖŸáŸÖ ÿ®€åŸÖÿßÿ± ÿßÿ±ÿßÿ¶Ÿá ŸÖ€å‚Äåÿ¥ŸàŸÜÿØ.
- ÿß€åŸÜ ÿß⁄©ÿ¥ŸÜ ÿµÿ±ŸÅÿßŸã ÿÆŸàÿßŸÜÿØŸÜ Ÿà ÿ≥ÿ±€åÿßŸÑÿß€åÿ≤ ⁄©ÿ±ÿØŸÜ ÿ±⁄©Ÿàÿ±ÿØŸáÿß€å AISummary ÿ±ÿß ÿßŸÜÿ¨ÿßŸÖ ŸÖ€å‚ÄåÿØŸáÿØ Ÿà Ÿá€å⁄Ü Ÿæÿ±ÿØÿßÿ≤ÿ¥ €åÿß ÿßÿ¨ÿ±ÿß€å ÿ™ÿ≥⁄© ÿ∂ŸÖŸÜ€å (ŸÖÿ´ŸÑ ŸÅÿ±ÿßÿÆŸàÿßŸÜ€å ŸÖÿØŸÑ €åÿß ÿß€åÿ¨ÿßÿØ Ÿàÿ∏€åŸÅŸá Ÿæÿ≥‚Äåÿ≤ŸÖ€åŸÜŸá) ÿ±ÿß ÿ±ÿßŸá‚ÄåÿßŸÜÿØÿßÿ≤€å ŸÜŸÖ€å‚Äå⁄©ŸÜÿØÿõ ÿß⁄Øÿ± ŸÜ€åÿßÿ≤ ÿ®Ÿá ÿ™ŸàŸÑ€åÿØ €åÿß ÿ®Ÿá‚Äåÿ±Ÿàÿ≤ÿ±ÿ≥ÿßŸÜ€å ÿÆŸÑÿßÿµŸá‚ÄåŸáÿß€å ŸáŸàÿ¥‚ÄåŸÖÿµŸÜŸàÿπ€å ÿ®ÿßÿ¥ÿØÿå ÿ¢ŸÜ ÿπŸÖŸÑ€åÿßÿ™ ÿ®ÿß€åÿØ ÿßÿ≤ ŸÖÿ≥€åÿ±Ÿáÿß€å ÿ¨ÿØÿß⁄ØÿßŸÜŸá ŸÖÿØ€åÿ±€åÿ™ ÿ¥ŸàÿØ.

ÿπŸàÿßÿ±ÿ∂ ÿ¨ÿßŸÜÿ®€å Ÿà ÿÆÿ∑ÿßŸáÿß:
- ÿÆŸàÿØ ÿ™ÿßÿ®ÿπ ÿØÿßÿØŸá‚ÄåŸáÿß ÿ±ÿß ÿ™ÿ∫€å€åÿ± ŸÜŸÖ€å‚ÄåÿØŸáÿØÿõ ÿØÿ± ÿµŸàÿ±ÿ™ ŸÜÿ®ŸàÿØŸÜ ÿØÿ≥ÿ™ÿ±ÿ≥€å €åÿß Ÿàÿ¨ŸàÿØ ÿÆÿ∑ÿß ÿØÿ± ÿ®ÿßÿ≤€åÿßÿ®€å ÿ¢ÿ®ÿ¨⁄©ÿ™ ÿ®€åŸÖÿßÿ±ÿå ÿÆÿ∑ÿßŸáÿß€å ŸÖÿ±ÿ®Ÿàÿ∑ ÿ®Ÿá permissions €åÿß 404 ÿ™Ÿàÿ≥ÿ∑ ŸÖÿ™ÿØŸáÿß€å Ÿæÿß€åŸáŸî ViewSet/DRF ÿ™ŸàŸÑ€åÿØ ŸÖ€å‚Äåÿ¥ŸàŸÜÿØ.
 * @summary Get patient timeline
 */
export const apiPatientsTimelineRetrieve = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Patient>> => {
    
    
    return axios.default.get(
      `/api/patients/${id}/timeline`,options
    );
  }


export const getApiPatientsTimelineRetrieveQueryKey = (id: number,) => {
    return [`/api/patients/${id}/timeline`] as const;
    }

    
export const getApiPatientsTimelineRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof apiPatientsTimelineRetrieve>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseQueryOptions<TData, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiPatientsTimelineRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiPatientsTimelineRetrieve>>> = ({ signal }) => apiPatientsTimelineRetrieve(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<TData, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ApiPatientsTimelineRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof apiPatientsTimelineRetrieve>>>
export type ApiPatientsTimelineRetrieveQueryError = AxiosError<void>


export function useApiPatientsTimelineRetrieve<TData = Awaited<ReturnType<typeof apiPatientsTimelineRetrieve>>, TError = AxiosError<void>>(
 id: number, options: { query:Partial<UseQueryOptions<TData, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          TData,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiPatientsTimelineRetrieve<TData = Awaited<ReturnType<typeof apiPatientsTimelineRetrieve>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<TData, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          TData,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiPatientsTimelineRetrieve<TData = Awaited<ReturnType<typeof apiPatientsTimelineRetrieve>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<TData, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get patient timeline
 */

export function useApiPatientsTimelineRetrieve<TData = Awaited<ReturnType<typeof apiPatientsTimelineRetrieve>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<TData, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getApiPatientsTimelineRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary List clinical references
 */
export const apiRefsList = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ClinicalReference[]>> => {
    
    
    return axios.default.get(
      `/api/refs`,options
    );
  }


export const getApiRefsListQueryKey = () => {
    return [`/api/refs`] as const;
    }

    
export const getApiRefsListQueryOptions = <TData = Awaited<ReturnType<typeof apiRefsList>>, TError = AxiosError<void>>( options?: { query?:Partial<UseQueryOptions<TData, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiRefsListQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiRefsList>>> = ({ signal }) => apiRefsList({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<TData, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ApiRefsListQueryResult = NonNullable<Awaited<ReturnType<typeof apiRefsList>>>
export type ApiRefsListQueryError = AxiosError<void>


export function useApiRefsList<TData = Awaited<ReturnType<typeof apiRefsList>>, TError = AxiosError<void>>(
  options: { query:Partial<UseQueryOptions<TData, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          TData,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiRefsList<TData = Awaited<ReturnType<typeof apiRefsList>>, TError = AxiosError<void>>(
  options?: { query?:Partial<UseQueryOptions<TData, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          TData,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiRefsList<TData = Awaited<ReturnType<typeof apiRefsList>>, TError = AxiosError<void>>(
  options?: { query?:Partial<UseQueryOptions<TData, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List clinical references
 */

export function useApiRefsList<TData = Awaited<ReturnType<typeof apiRefsList>>, TError = AxiosError<void>>(
  options?: { query?:Partial<UseQueryOptions<TData, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getApiRefsListQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Create clinical reference
 */
export const apiRefsCreate = (
    clinicalReference: NonReadonly<ClinicalReference>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ClinicalReference>> => {
    
    
    return axios.default.post(
      `/api/refs`,
      clinicalReference,options
    );
  }



export const getApiRefsCreateMutationOptions = <TData = Awaited<ReturnType<typeof apiRefsCreate>>, TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: NonReadonly<ClinicalReference>}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['apiRefsCreate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiRefsCreate>>, {data: NonReadonly<ClinicalReference>}> = (props) => {
          const {data} = props ?? {};

          return  apiRefsCreate(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: NonReadonly<ClinicalReference>}, TContext>}

    export type ApiRefsCreateMutationResult = NonNullable<Awaited<ReturnType<typeof apiRefsCreate>>>
    export type ApiRefsCreateMutationBody = NonReadonly<ClinicalReference>
    export type ApiRefsCreateMutationError = AxiosError<void>

    /**
 * @summary Create clinical reference
 */
export const useApiRefsCreate = <TData = Awaited<ReturnType<typeof apiRefsCreate>>, TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: NonReadonly<ClinicalReference>}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {data: NonReadonly<ClinicalReference>},
        TContext
      > => {

      const mutationOptions = getApiRefsCreateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get clinical reference
 */
export const apiRefsRetrieve = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ClinicalReference>> => {
    
    
    return axios.default.get(
      `/api/refs/${id}`,options
    );
  }


export const getApiRefsRetrieveQueryKey = (id: number,) => {
    return [`/api/refs/${id}`] as const;
    }

    
export const getApiRefsRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof apiRefsRetrieve>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseQueryOptions<TData, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiRefsRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiRefsRetrieve>>> = ({ signal }) => apiRefsRetrieve(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<TData, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ApiRefsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof apiRefsRetrieve>>>
export type ApiRefsRetrieveQueryError = AxiosError<void>


export function useApiRefsRetrieve<TData = Awaited<ReturnType<typeof apiRefsRetrieve>>, TError = AxiosError<void>>(
 id: number, options: { query:Partial<UseQueryOptions<TData, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          TData,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiRefsRetrieve<TData = Awaited<ReturnType<typeof apiRefsRetrieve>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<TData, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          TData,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiRefsRetrieve<TData = Awaited<ReturnType<typeof apiRefsRetrieve>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<TData, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get clinical reference
 */

export function useApiRefsRetrieve<TData = Awaited<ReturnType<typeof apiRefsRetrieve>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<TData, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getApiRefsRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Update clinical reference
 */
export const apiRefsUpdate = (
    id: number,
    clinicalReference: NonReadonly<ClinicalReference>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ClinicalReference>> => {
    
    
    return axios.default.put(
      `/api/refs/${id}`,
      clinicalReference,options
    );
  }



export const getApiRefsUpdateMutationOptions = <TData = Awaited<ReturnType<typeof apiRefsUpdate>>, TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: NonReadonly<ClinicalReference>}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['apiRefsUpdate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiRefsUpdate>>, {id: number;data: NonReadonly<ClinicalReference>}> = (props) => {
          const {id,data} = props ?? {};

          return  apiRefsUpdate(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: NonReadonly<ClinicalReference>}, TContext>}

    export type ApiRefsUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof apiRefsUpdate>>>
    export type ApiRefsUpdateMutationBody = NonReadonly<ClinicalReference>
    export type ApiRefsUpdateMutationError = AxiosError<void>

    /**
 * @summary Update clinical reference
 */
export const useApiRefsUpdate = <TData = Awaited<ReturnType<typeof apiRefsUpdate>>, TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: NonReadonly<ClinicalReference>}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number;data: NonReadonly<ClinicalReference>},
        TContext
      > => {

      const mutationOptions = getApiRefsUpdateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Partially update clinical reference
 */
export const apiRefsPartialUpdate = (
    id: number,
    patchedClinicalReference: NonReadonly<PatchedClinicalReference>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ClinicalReference>> => {
    
    
    return axios.default.patch(
      `/api/refs/${id}`,
      patchedClinicalReference,options
    );
  }



export const getApiRefsPartialUpdateMutationOptions = <TData = Awaited<ReturnType<typeof apiRefsPartialUpdate>>, TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: NonReadonly<PatchedClinicalReference>}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['apiRefsPartialUpdate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiRefsPartialUpdate>>, {id: number;data: NonReadonly<PatchedClinicalReference>}> = (props) => {
          const {id,data} = props ?? {};

          return  apiRefsPartialUpdate(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: NonReadonly<PatchedClinicalReference>}, TContext>}

    export type ApiRefsPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof apiRefsPartialUpdate>>>
    export type ApiRefsPartialUpdateMutationBody = NonReadonly<PatchedClinicalReference>
    export type ApiRefsPartialUpdateMutationError = AxiosError<void>

    /**
 * @summary Partially update clinical reference
 */
export const useApiRefsPartialUpdate = <TData = Awaited<ReturnType<typeof apiRefsPartialUpdate>>, TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: NonReadonly<PatchedClinicalReference>}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number;data: NonReadonly<PatchedClinicalReference>},
        TContext
      > => {

      const mutationOptions = getApiRefsPartialUpdateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Delete clinical reference
 */
export const apiRefsDestroy = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.default.delete(
      `/api/refs/${id}`,options
    );
  }



export const getApiRefsDestroyMutationOptions = <TData = Awaited<ReturnType<typeof apiRefsDestroy>>, TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['apiRefsDestroy'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiRefsDestroy>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  apiRefsDestroy(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type ApiRefsDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof apiRefsDestroy>>>
    
    export type ApiRefsDestroyMutationError = AxiosError<void>

    /**
 * @summary Delete clinical reference
 */
export const useApiRefsDestroy = <TData = Awaited<ReturnType<typeof apiRefsDestroy>>, TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getApiRefsDestroyMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Takes a set of user credentials and returns an access and refresh JSON web
token pair to prove the authentication of those credentials.
 * @summary Obtain JWT token pair
 */
export const apiTokenCreate = (
    tokenObtainPair: NonReadonly<TokenObtainPair>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TokenObtainPair>> => {
    
    
    return axios.default.post(
      `/api/token`,
      tokenObtainPair,options
    );
  }



export const getApiTokenCreateMutationOptions = <TData = Awaited<ReturnType<typeof apiTokenCreate>>, TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: NonReadonly<TokenObtainPair>}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['apiTokenCreate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiTokenCreate>>, {data: NonReadonly<TokenObtainPair>}> = (props) => {
          const {data} = props ?? {};

          return  apiTokenCreate(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: NonReadonly<TokenObtainPair>}, TContext>}

    export type ApiTokenCreateMutationResult = NonNullable<Awaited<ReturnType<typeof apiTokenCreate>>>
    export type ApiTokenCreateMutationBody = NonReadonly<TokenObtainPair>
    export type ApiTokenCreateMutationError = AxiosError<void>

    /**
 * @summary Obtain JWT token pair
 */
export const useApiTokenCreate = <TData = Awaited<ReturnType<typeof apiTokenCreate>>, TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: NonReadonly<TokenObtainPair>}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {data: NonReadonly<TokenObtainPair>},
        TContext
      > => {

      const mutationOptions = getApiTokenCreateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Takes a refresh type JSON web token and returns an access type JSON web
token if the refresh token is valid.
 * @summary Refresh JWT access token
 */
export const apiTokenRefreshCreate = (
    tokenRefresh: NonReadonly<TokenRefresh>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TokenRefresh>> => {
    
    
    return axios.default.post(
      `/api/token/refresh`,
      tokenRefresh,options
    );
  }



export const getApiTokenRefreshCreateMutationOptions = <TData = Awaited<ReturnType<typeof apiTokenRefreshCreate>>, TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: NonReadonly<TokenRefresh>}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['apiTokenRefreshCreate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiTokenRefreshCreate>>, {data: NonReadonly<TokenRefresh>}> = (props) => {
          const {data} = props ?? {};

          return  apiTokenRefreshCreate(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: NonReadonly<TokenRefresh>}, TContext>}

    export type ApiTokenRefreshCreateMutationResult = NonNullable<Awaited<ReturnType<typeof apiTokenRefreshCreate>>>
    export type ApiTokenRefreshCreateMutationBody = NonReadonly<TokenRefresh>
    export type ApiTokenRefreshCreateMutationError = AxiosError<void>

    /**
 * @summary Refresh JWT access token
 */
export const useApiTokenRefreshCreate = <TData = Awaited<ReturnType<typeof apiTokenRefreshCreate>>, TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: NonReadonly<TokenRefresh>}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {data: NonReadonly<TokenRefresh>},
        TContext
      > => {

      const mutationOptions = getApiTokenRefreshCreateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get resource versions
 */
export const apiVersionsRetrieve = (
    resourceType: string,
    resourceId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.default.get(
      `/api/versions/${resourceType}/${resourceId}`,options
    );
  }


export const getApiVersionsRetrieveQueryKey = (resourceType: string,
    resourceId: string,) => {
    return [`/api/versions/${resourceType}/${resourceId}`] as const;
    }

    
export const getApiVersionsRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof apiVersionsRetrieve>>, TError = AxiosError<void>>(resourceType: string,
    resourceId: string, options?: { query?:Partial<UseQueryOptions<TData, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiVersionsRetrieveQueryKey(resourceType,resourceId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiVersionsRetrieve>>> = ({ signal }) => apiVersionsRetrieve(resourceType,resourceId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(resourceType && resourceId), ...queryOptions} as UseQueryOptions<TData, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ApiVersionsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof apiVersionsRetrieve>>>
export type ApiVersionsRetrieveQueryError = AxiosError<void>


export function useApiVersionsRetrieve<TData = Awaited<ReturnType<typeof apiVersionsRetrieve>>, TError = AxiosError<void>>(
 resourceType: string,
    resourceId: string, options: { query:Partial<UseQueryOptions<TData, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          TData,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiVersionsRetrieve<TData = Awaited<ReturnType<typeof apiVersionsRetrieve>>, TError = AxiosError<void>>(
 resourceType: string,
    resourceId: string, options?: { query?:Partial<UseQueryOptions<TData, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          TData,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useApiVersionsRetrieve<TData = Awaited<ReturnType<typeof apiVersionsRetrieve>>, TError = AxiosError<void>>(
 resourceType: string,
    resourceId: string, options?: { query?:Partial<UseQueryOptions<TData, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get resource versions
 */

export function useApiVersionsRetrieve<TData = Awaited<ReturnType<typeof apiVersionsRetrieve>>, TError = AxiosError<void>>(
 resourceType: string,
    resourceId: string, options?: { query?:Partial<UseQueryOptions<TData, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getApiVersionsRetrieveQueryOptions(resourceType,resourceId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Revert resource to previous version
 */
export const apiVersionsRevertCreate = (
    resourceType: string,
    resourceId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.default.post(
      `/api/versions/${resourceType}/${resourceId}/revert`,undefined,options
    );
  }



export const getApiVersionsRevertCreateMutationOptions = <TData = Awaited<ReturnType<typeof apiVersionsRevertCreate>>, TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{resourceType: string;resourceId: string}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['apiVersionsRevertCreate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiVersionsRevertCreate>>, {resourceType: string;resourceId: string}> = (props) => {
          const {resourceType,resourceId} = props ?? {};

          return  apiVersionsRevertCreate(resourceType,resourceId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{resourceType: string;resourceId: string}, TContext>}

    export type ApiVersionsRevertCreateMutationResult = NonNullable<Awaited<ReturnType<typeof apiVersionsRevertCreate>>>
    
    export type ApiVersionsRevertCreateMutationError = AxiosError<void>

    /**
 * @summary Revert resource to previous version
 */
export const useApiVersionsRevertCreate = <TData = Awaited<ReturnType<typeof apiVersionsRevertCreate>>, TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{resourceType: string;resourceId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {resourceType: string;resourceId: string},
        TContext
      > => {

      const mutationOptions = getApiVersionsRevertCreateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
